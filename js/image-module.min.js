// js/image-module.min.js (Substituir conteÃºdo)
(function (window) {
    "use strict";
    if (!window.docxtemplater) {
        throw new Error("docxtemplater not found, please be sure to include docxtemplater.min.js");
    }

    const DocUtils = window.docxtemplater.DocUtils;
    const DOMParser = window.DOMParser;
    DocUtils.convertPixelsToEmus = (pixel) => Math.round(pixel * 9525);

    const templates = {
        getImageXml: (rId, size) => `<w:drawing><wp:inline distT="0" distB="0" distL="0" distR="0"><wp:extent cx="${size[0]}" cy="${size[1]}"/><wp:effectExtent l="0" t="0" r="0" b="0"/><wp:docPr id="2" name="Image" descr="image"/><wp:cNvGraphicFramePr><a:graphicFrameLocks xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" noChangeAspect="1"/></wp:cNvGraphicFramePr><a:graphic xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main"><a:graphicData uri="http://schemas.openxmlformats.org/drawingml/2006/picture"><pic:pic xmlns:pic="http://schemas.openxmlformats.org/drawingml/2006/picture"><pic:nvPicPr><pic:cNvPr id="0" name="Picture"/><pic:cNvPicPr><a:picLocks noChangeAspect="1" noChangeArrowheads="1"/></pic:cNvPicPr></pic:nvPicPr><pic:blipFill><a:blip r:embed="rId${rId}"/><a:stretch><a:fillRect/></a:stretch></pic:blipFill><pic:spPr bwMode="auto"><a:xfrm><a:off x="0" y="0"/><a:ext cx="${size[0]}" cy="${size[1]}"/></a:xfrm><a:prstGeom prst="rect"><a:avLst/></a:prstGeom><a:noFill/><a:ln><a:noFill/></a:ln></pic:spPr></pic:pic></a:graphicData></a:graphic></wp:inline></w:drawing>`,
        getImageXmlCentered: (rId, size) => `<w:p><w:pPr><w:jc w:val="center"/></w:pPr><w:r><w:drawing><wp:inline distT="0" distB="0" distL="0" distR="0"><wp:extent cx="${size[0]}" cy="${size[1]}"/><wp:docPr id="0" name="Picture" descr=""/><a:graphic xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main"><a:graphicData uri="http://schemas.openxmlformats.org/drawingml/2006/picture"><pic:pic xmlns:pic="http://schemas.openxmlformats.org/drawingml/2006/picture"><pic:nvPicPr><pic:cNvPr id="0" name="Picture" descr=""/><pic:cNvPicPr><a:picLocks noChangeAspect="1" noChangeArrowheads="1"/></pic:cNvPicPr></pic:nvPicPr><pic:blipFill><a:blip r:embed="rId${rId}"/><a:stretch><a:fillRect/></a:stretch></pic:blipFill><pic:spPr bwMode="auto"><a:xfrm><a:off x="0" y="0"/><a:ext cx="${size[0]}" cy="${size[1]}"/></a:xfrm><a:prstGeom prst="rect"><a:avLst/></a:prstGeom><a:noFill/><a:ln w="9525"><a:noFill/><a:miter lim="800000"/><a:headEnd/><a:tailEnd/></a:ln></pic:spPr></pic:pic></a:graphicData></a:graphic></wp:inline></w:drawing></w:r></w:p>`
    };

    class ImgManager {
        constructor(zip, fileName, xmlDocuments, fileType) {
            this.zip = zip;
            this.xmlDocuments = xmlDocuments;
            this.fileType = fileType;
            const prefix = fileType === "docx" ? "word" : "ppt";
            const fileTypeName = fileType === "docx" ? "document" : "presentation";
            this.mediaPrefix = fileType === "pptx" ? "../media" : "media";
            const relsFileName = fileName.replace(/^.*?([a-zA-Z0-9]+)\.xml$/, "$1") + ".xml.rels";
            const relsFilePath = (fileType === "pptx" ? "ppt/slides" : "word") + "/_rels/" + relsFileName;
            
            this.relsDoc = xmlDocuments[relsFilePath] || this.createEmptyRelsDoc(xmlDocuments, relsFilePath, prefix, fileTypeName);
        }

        createEmptyRelsDoc(xmlDocuments, relsFileName, prefix, fileTypeName) {
            const mainRels = prefix + "/_rels/" + fileTypeName + ".xml.rels";
            const doc = xmlDocuments[mainRels];
            if (!doc) {
                throw new Error("Could not find main rels file.");
            }
            const relsDoc = DocUtils.str2xml(DocUtils.xml2str(doc));
            const relationships = relsDoc.getElementsByTagName("Relationships")[0];
            while (relationships.firstChild) {
                relationships.removeChild(relationships.firstChild);
            }
            xmlDocuments[relsFileName] = relsDoc;
            return relsDoc;
        }
        
        loadImageRels() {
            const relationships = this.relsDoc.getElementsByTagName("Relationship");
            return Array.prototype.reduce.call(relationships, (max, r) => {
                const id = r.getAttribute("Id");
                return /^rId[0-9]+$/.test(id) ? Math.max(max, parseInt(id.substr(3), 10)) : max;
            }, 0);
        }

        addExtensionRels(contentType, extension) {
            const contentTypeDoc = this.xmlDocuments["[Content_Types].xml"];
            const types = contentTypeDoc.getElementsByTagName("Types")[0];
            const defaults = types.getElementsByTagName("Default");
            if (Array.prototype.some.call(defaults, tag => tag.getAttribute("Extension") === extension)) {
                return;
            }
            const newTagStr = `<Default Extension="${extension}" ContentType="${contentType}"/>`;
            const newTagNode = new DOMParser().parseFromString(newTagStr, "text/xml").documentElement;
            types.appendChild(newTagNode);
        }

        addImageRels(imageName, imageData) {
            const imagePath = (this.fileType === "docx" ? "word" : "ppt") + "/media/" + imageName;
            if (this.zip.files[imagePath]) {
                return this.addImageRels("image" + Date.now() + ".png", imageData);
            }
            this.zip.file(imagePath, imageData, { binary: true, base64: true });
            const extension = imageName.split('.').pop();
            this.addExtensionRels("image/" + extension, extension);

            const relationships = this.relsDoc.getElementsByTagName("Relationships")[0];
            const newTag = this.relsDoc.createElement("Relationship");
            const maxRid = this.loadImageRels() + 1;
            newTag.setAttribute("Id", "rId" + maxRid);
            newTag.setAttribute("Type", "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image");
            newTag.setAttribute("Target", this.mediaPrefix + "/" + imageName);
            relationships.appendChild(newTag);
            return maxRid;
        }
    }

    class ImageModule {
        constructor(options) {
            this.name = "ImageModule";
            this.options = options || {};
            if (!this.options.getImage) throw new Error("getImage option is required");
            if (!this.options.getSize) throw new Error("getSize option is required");
            this.imageNumber = 1;
        }

        optionsTransformer(options, docxtemplater) {
            this.fileType = docxtemplater.fileType;
            const relsFiles = docxtemplater.zip.file(/\.xml\.rels/).concat(docxtemplater.zip.file(/\[Content_Types\].xml/)).map(file => file.name);
            options.xmlFileNames = [...options.xmlFileNames, ...relsFiles];
            return options;
        }
        
        set(options) {
            if (options.zip) this.zip = options.zip;
            if (options.xmlDocuments) this.xmlDocuments = options.xmlDocuments;
        }

        parse(placeHolderContent) {
            if (placeHolderContent.startsWith('%')) {
                return {
                    type: "placeholder",
                    value: placeHolderContent.substring(1),
                    module: this.name,
                    centered: placeHolderContent.startsWith('%%')
                };
            }
            return null;
        }

        render(part, options) {
            if (part.module !== this.name) return null;
            
            const tagValue = options.scopeManager.getValue(part.value, { part });
            if (!tagValue) return { value: "" };
            
            const imgManager = new ImgManager(this.zip, options.filePath, this.xmlDocuments, this.fileType);
            const imgBuffer = this.options.getImage(tagValue, part.value);
            if (!imgBuffer) return { value: "" };

            const rId = imgManager.addImageRels(this.getNextImageName(), imgBuffer);
            const sizePixel = this.options.getSize(imgBuffer, tagValue, part.value);
            
            return this.getRenderedPart(rId, sizePixel, part.centered);
        }

        getRenderedPart(rId, sizePixel, centered) {
            const size = [DocUtils.convertPixelsToEmus(sizePixel[0]), DocUtils.convertPixelsToEmus(sizePixel[1])];
            const template = centered ? templates.getImageXmlCentered(rId, size) : templates.getImageXml(rId, size);
            return { value: template };
        }
        
        getNextImageName() {
            return `image_generated_${this.imageNumber++}.png`;
        }
    }

    window.ImageModule = ImageModule;

})(window);